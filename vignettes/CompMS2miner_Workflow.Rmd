---
title: "CompMS2miner_Workflow"
author: "WMB Edmands"
date: '`r format(Sys.Date(), "%B %e, %Y")`'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{CompMS2miner_Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

Matches MS1 features to MS2 spectra (.mzXML) files based on a 
mass-to-charge and retention time tolerance. Composite spectra and other data
can subsequently be visualized during any stage of the CompMS2miner
processing workflow. Composite spectra can be denoised, ion signals grouped 
and summed, substructure groups identified, common Phase II metabolites
predicted, calculation of a correlation network and features matched to data bases monoisotopic mass data and insilico MS2 fragmentation data.
The resulting data can then be readily curated by publishing as online shiny application on shinyapps.io, as a zip file which can be shared or by sending to a local or online couchDB database. 

At any stage during the compMS2 workflow a compMS2 class object can be visualized
with a Shiny application *compMS2explorer*. Full usage of the *compMS2explorer* application functionality requires an internet connection.
The end result of following the workflow within this document using the example data provided can be visualized using the function, comments made in the metID comments
tab can be saved on closing the application by assigning the compMS2explorer
output to an object:

```{r, eval=FALSE}
library(CompMS2miner)
# assign any metabolite identification comments to a new or the same "CompMS2" object
compMS2example_commented <- compMS2explorer(compMS2example)
```
The following example illustrates the CompMS2miner workflow:

## 1. construct compMS2 class object.
From MS2 data (in the .mzXML file format) and an MS1feature table. The compMS2 object can also be constructed in as a parallel computation in the case of large peak tables and/ or larger numbers of MS2 data files.
```{r, include=F}
library(knitr)
opts_knit$set(progress=FALSE)
library(CompMS2miner)
```
```{r, collapse=TRUE}
# file path example MS1features in comma delimited csv file 
# (see ?example_mzXML_MS1features for details).
MS1features_example <- system.file("extdata", "MS1features_example.csv", 
                                   package = "CompMS2miner")
# mzXml file examples directory
mzXmlDir_example <- dirname(MS1features_example)
# observation MS1 feature table column names character vector for corrNetwork function
obsNames <- c(paste0(rep("ACN_80_", 6), rep(LETTERS[1:3], each=2), rep(1:2, 3)),
              paste0(rep("MeOH_80_", 6), rep(LETTERS[1:3], each=2), rep(1:2, 3)))
# use parallel package to detect number of cores
nCores <- parallel::detectCores()

# read in example peakTable
peakTable <- read.csv(MS1features_example, header=TRUE, stringsAsFactors=FALSE) 
# create compMS2 object
compMS2demo <- compMS2(MS1features = peakTable,
                       mzXMLdir = mzXmlDir_example, nCores=nCores,
                       mode = "pos", precursorPpm = 10, ret = 20, 
                       TICfilter = 10000)

# View summary of compMS2 class object at any time 
compMS2demo
```

##2. Dynamic noise filtration.
filter variable noise from the data using a dynamic noise filter.
```{r, collapse=TRUE}
# dynamic noise filter
compMS2demo <- deconvNoise(compMS2demo, "DNF")
# View summary of compMS2 class object at any time 
compMS2demo 

```

##3. Intra-spectrum ion grouping and inter-MS2 file spectra grouping with signal summing.
group and sum ions from different scans and then combine summed ion composite spectra
across multiple files. This create a single composite spectra for each MS1 EIC
matched to MS2 precursor scans.
```{r, collapse=TRUE}
# intra-spectrum ion grouping and signal summing
compMS2demo <- combineMS2(compMS2demo, "Ions")
# View summary of compMS2 class object at any time 
compMS2demo
#inter spectrum ion grouping and signal summing
compMS2demo <- combineMS2(compMS2demo, "Spectra") 
# View summary of compMS2 class object at any time 
compMS2demo

```

## 4. Possible substructure identification. 
Characteristic neutral losses/ fragments of electrospray adducts and metabolites from literature sources (?Substructure_masses for details).
```{r, collapse=TRUE}
# annotate substructures
compMS2demo <- subStructure(compMS2demo, "Annotate")
# identify most probable substructure annotation based on total relative intensity
# explained
compMS2demo <- subStructure(compMS2demo, "prob")
# summary of most probable substructure annotation
mostProbSubStr <- subStructure(compMS2demo, "probSummary")

```

##5. Metabolite identification methods.
A variety of metabolite identification methods are implemented through the
function metID (see ?metID) for further details.
```{r, collapse=TRUE}
# annotate composite MS2 matched MS1 features to metabolomic databases (default
#is HMDB, also DrugBank, T3DB and ReSpect databases can also be queried).
#Warning: this may take 2-3 mins as large number of query masses
compMS2demo <- metID(compMS2demo, "dbAnnotate")

# select most probable annotations based on substructures detected
compMS2demo <- metID(compMS2demo, "dbProb")
```

```{r, eval=FALSE, collapse=TRUE}
# match composite spectra to spectral databases as .msp files (e.g. lipidBlast, source http://prime.psc.riken.jp/Metabolomics_Software/MS-DIAL/LipidBlast_Posi_Plasma_vs2.msp)
compMS2demo <- metID(compMS2demo, 'matchSpectralDB',
                     mspFile='http://prime.psc.riken.jp/Metabolomics_Software/MS-DIAL/LipidBlast_Posi_Plasma_vs2.msp')
# massBank .msp
compMS2demo <- metID(compMS2demo, 'matchSpectralDB',
                     mspFile='http://prime.psc.riken.jp/Metabolomics_Software/MS-DIAL/MassBank_MSMS_Pos_Rev173_vs1.msp')

# ReSpect .msp
compMS2demo <- metID(compMS2demo, 'matchSpectralDB', 
                     mspFile='http://prime.psc.riken.jp/Metabolomics_Software/MS-DIAL/Respect_20120925_ESI_Positive_MSMS.msp')

```

```{r, eval=FALSE, collapse=TRUE}
# predict Phase II metabolites from SMILES codes
compMS2demo <- metID(compMS2demo, "predSMILES")

# metFrag insilico fragmentation.
compMS2demo <- metID(compMS2demo, "metFrag")
```

### spectral similarity network, MetMSLine data-preprocessing and correlation network calculation.
```{r, collapse=TRUE}
# calculate spectral similarity network (dot product >= 0.8 default)
compMS2demo <- metID(compMS2demo, 'specSimNetwork')
##############################################################
### data pre-processing MS1features with MetMSLine package ###
##############################################################

if(!require(MetMSLine)){
  # if not installed then install from github
  devtools::install_github('WMBEdmands/MetMSLine')
  require(MetMSLine)
}

# zero fill
peakTable <- zeroFill(peakTable, obsNames)
# log transform
peakTable <- logTrans(peakTable, obsNames)

########################################################
######### end MetMSLine pre-processing #################
########################################################

# add correlation network using pre-processed MS2 matched peak table
compMS2demo <- metID(compMS2demo, method='corrNetwork', peakTable, obsNames,
                     corrMethod='pearson', corrThresh=0.95, MTC='none', MS2only=3)
```

##6. Optional curate data as zip file, in CouchDB and/or publish results as a shiny application. 
CompMS2 class objects can be sent to either a local or online couchDB database.
Furthermore, the results of the CompMS2miner workflow can be published on the 
web as a shiny application to share metabolite identification information or as a self-contained zip file using the publishApp function.

```{r, eval=FALSE, collapse=TRUE}
# publish your app to shinyapps.io see ?publishApp for more details
# you may need to install the rsconnect and shinyapps packages and also sign up for a shinyapps.io account if you don't have one.
# quick guide here for setting up your account: http://shiny.rstudio.com/articles/shinyapps.html
publishApp(compMS2demo, appName='compMS2demo')

```

# sessionInfo

```{r}
sessionInfo()
```
