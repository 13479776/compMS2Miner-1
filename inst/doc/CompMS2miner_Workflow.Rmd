---
title: "CompMS2miner_Workflow"
author: "WMB Edmands"
date: '`r format(Sys.Date(), "%B %e, %Y")`'
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{CompMS2miner_Workflow}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

Matches MS1 features to MS2 spectra (.mzXML) files based on a 
mass-to-charge and retention time tolerance. Composite spectra and other data
can subsequently be visualized during any stage of the CompMS2miner
processing workflow. Composite spectra can be denoised, ion signals grouped 
and summed, substructure groups identified, common Phase II metabolites
predicted, calculation of a correlation network and features matched to data bases monoisotopic mass data and insilico MS2 fragmentation data.
The resulting data can then be readily curated by publishing as online shiny application on shinyapps.io, as a zip file which can be shared or by sending to a local or online
couchDB database. 

At any stage during the compMS2 workflow a compMS2 class object can be visualized
with a Shiny application *compMS2explorer*. Full usage of the *compMS2explorer* application functionality requires an internet connection.
The end result of following the workflow within this document using the example data provided can be visualized using the function:

```{r, eval=FALSE}
library(CompMS2miner)
compMS2explorer(compMS2example)
```
The following example illustrates the CompMS2miner workflow:

## 1. construct compMS2 class object.
From MS2 data (in the .mzXML file format) and an MS1feature table. The compMS2 object can also be constructed in as a parallel computation in the case of large peak tables and/ or larger numbers of MS2 data files.
```{r, include=F}
library(CompMS2miner)
```
```{r, collapse=TRUE}
# file path example MS1features in comma delimited csv file 
# (see ?example_mzXML_MS1features for details).
MS1features_example <- system.file("extdata", "MS1features_example.csv", 
                                   package = "CompMS2miner")
# mzXml file examples directory
mzXmlDir_example <- dirname(MS1features_example)
# observation MS1 feature table column names character vector for corrNetwork function
obsNames <- c(paste0(rep("ACN_80_", 6), rep(LETTERS[1:3], each=2), rep(1:2, 3)),
              paste0(rep("MeOH_80_", 6), rep(LETTERS[1:3], each=2), rep(1:2, 3)))
# use parallel package to detect number of cores
nCores <- parallel::detectCores()

# read in example peakTable
peakTable <- read.csv(MS1features_example, header=TRUE, stringsAsFactors=FALSE) 
# create compMS2 object
compMS2demo <- compMS2(MS1features = peakTable,
                       mzXMLdir = mzXmlDir_example, nCores=nCores,
                       mode = "pos", precursorPpm = 10, ret = 10, 
                       TICfilter = 10000)

# View summary of compMS2 class object at any time 
compMS2demo
```

##2. Dynamic noise filtration.
filter variable noise from the data using a dynamic noise filter.
```{r, collapse=TRUE}
# dynamic noise filter
compMS2demo <- deconvNoise(compMS2demo, "DNF")
# View summary of compMS2 class object at any time 
compMS2demo 

```

##3. Intra-spectrum ion grouping and inter-MS2 file spectra grouping with signal summing.
group and sum ions from different scans and then combine summed ion composite spectra
across multiple files. This create a single composite spectra for each MS1 EIC
matched to MS2 precursor scans.
```{r, collapse=TRUE}
# intra-spectrum ion grouping and signal summing
compMS2demo <- combineMS2(compMS2demo, "Ions")
# View summary of compMS2 class object at any time 
compMS2demo
#inter spectrum ion grouping and signal summing
compMS2demo <- combineMS2(compMS2demo, "Spectra") 
# View summary of compMS2 class object at any time 
compMS2demo

```

## 4. Possible substructure identification. 
Characteristic neutral losses/ fragments of electrospray adducts and metabolites from literature sources (?Substructure_masses for details).
```{r, collapse=TRUE}
# annotate substructures
compMS2demo <- subStructure(compMS2demo, "Annotate")
# identify most probable substructure annotation based on total relative intensity
# explained
compMS2demo <- subStructure(compMS2demo, "prob")
# summary of most probable substructure annotation
mostProbSubStr <- subStructure(compMS2demo, "probSummary")

```

##5. Metabolite identification methods.
A variety of metabolite identification methods are implemented through the
function metID (see ?metID) for further details.
```{r, collapse=TRUE}
# annotate composite MS2 matched MS1 features to metabolomic databases (default
#is HMDB, also DrugBank, T3DB and ReSpect databases can also be queried).
#Warning: this may take 2-3 mins as large number of query masses
compMS2demo <- metID(compMS2demo, "dbAnnotate")

# select most probable annotations based on substructures detected
compMS2demo <- metID(compMS2demo, "dbProb")
```

```{r, eval=FALSE, collapse=TRUE}
# predict Phase II metabolites from SMILES codes
compMS2demo <- metID(compMS2demo, "predSMILES")

# metFrag insilico fragmentation.
compMS2demo <- metID(compMS2demo, "metFrag")
```

### MetMSLine data-preprocessing and correlation network calculation.
```{r, collapse=TRUE}
##############################################################
### data pre-processing MS1features with MetMSLine package ###
##############################################################

if(!require(MetMSLine)){
  # if not installed then install from github
  devtools::install_github('WMBEdmands/MetMSLine')
  require(MetMSLine)
}

# zero fill
peakTable <- zeroFill(peakTable, obsNames)
# calculate coefficient of variation for Acetonitrile extraction replicates
peakTable <- cvCalc(peakTable, obsNames[grep('ACN', obsNames)], thresh=Inf)
# rename coeffVar column
colnames(peakTable)[ncol(peakTable)] <- 'coeffVar_ACN'
# calculate coefficient of variation for Methanol extraction replicates
peakTable <- cvCalc(peakTable, obsNames[grep('MeOH', obsNames)], thresh=Inf)
# rename coeffVar column
colnames(peakTable)[ncol(peakTable)] <- 'coeffVar_MeOH'
# all features less than 20% cv either ACN replicates or MeOH replicates
peakTable <- peakTable[peakTable$coeffVar_ACN <= 20 | peakTable$coeffVar_MeOH <= 20, ]
# deconvolute data with RamClust modified for MetMSLine
wMeanTable <- ramClustMod(peakTable, obsNames)
peakTable <- wMeanTable$wMeanPspec
# log transform
peakTable <- logTrans(peakTable, obsNames)

########################################################
######### end MetMSLine pre-processing #################
########################################################

# move eic nos to first column for corr network function
peakTable <- cbind(peakTable$EICno, peakTable)

# add correlation network using pre-processed peak table
compMS2demo <- metID(compMS2demo, method='corrNetwork', peakTable, obsNames, 
                           corrMethod='pearson', corrThresh=0.9, MTC='none')

```

##6. Optional curate data in CouchDB/ publish results as a shiny App. 
CompMS2 class objects can be sent to either a local or online couchDB database.
Furthermore, the results of the CompMS2miner workflow can be published on the 
web as a shiny application to share metabolite identification information using 
the publishApp function.

```{r, eval=FALSE, collapse=TRUE}
# publish your app to shinyapps.io see ?publishApp for more details
# you may need to install the rsconnect and shinyapps packages and also sign up for a shinyapps.io account if you don't have one.
# quick guide here for setting up your account: http://shiny.rstudio.com/articles/shinyapps.html
publishApp(compMS2demo, appName='compMS2demo')

```
